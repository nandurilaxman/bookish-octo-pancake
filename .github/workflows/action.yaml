name: Split Swagger YAML

on:
  workflow_dispatch:
    inputs:
      project_name:
        description: 'Project Name'
        required: true
      hcp_dataplane:
        description: 'HCP Dataplane'
        required: true
      hcp_environment:
        description: 'HCP Environment'
        required: true
      hcp_namespace:
        description: 'HCP Namespace'
        required: true
      Project_ServiceURL:
        description: 'Project Service URL'
        required: true
      UpstreamURLsuffix:
        description: 'Upstream URL Suffix'
        required: true
      env_deploy:
        description: 'Environment to Deploy'
        required: true
      hcpFile:
        description: 'HCP File Name'
        required: true
      artifactorytag:
        description: 'Artifactory Tag'
        required: true

jobs:
  split-swagger:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Setup .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: '6.0.x'

    - name: Restore dependencies
      run: dotnet restore src/API/SampleApi.csproj

    - name: Build project
      run: dotnet build src/API/SampleApi.csproj --configuration Release --no-restore

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'

    - name: Install Python dependencies
      shell: bash
      run: pip install pyyaml

    - name: Install dotnet swagger tool
      shell: bash
      run: dotnet tool install -g Swashbuckle.AspNetCore.Cli --version 6.2.3

    - name: Split Swagger YAML by path
      shell: bash
      env:
        PROJECT_NAME: ${{ inputs.project_name }}
        HCP_DATAPLANE: ${{ inputs.hcp_dataplane }}
        HCP_ENVIRONMENT: ${{ inputs.hcp_environment }}
        HCP_NAMESPACE: ${{ inputs.hcp_namespace }}
        PROJECT_SERVICE_URL: ${{ inputs.Project_ServiceURL }}
        HCP_URL_SUFFIXURL: ${{ inputs.UpstreamURLsuffix }}
        ENVIRONMENT: ${{github.event.inputs.env_deploy }}
      run: |
        python3 <<EOF
        import os
        import sys
        import subprocess
        import yaml
        import zipfile
        from collections import defaultdict
        from pathlib import Path

        project_name = os.environ.get("PROJECT_NAME").lower()
        dataplane = os.environ.get("HCP_DATAPLANE")
        hcp_environment = os.environ.get("HCP_ENVIRONMENT")
        namespace = os.environ.get("HCP_NAMESPACE")
        service_url = os.environ.get("PROJECT_SERVICE_URL")
        upstream_urlsuffixurl = os.environ.get("HCP_URL_SUFFIXURL")
        env = os.environ.get("ENVIRONMENT")
        artifactory_tag = os.environ.get("ARTIFACTORY_TAG")
        print("environment variable:", env)

        api_version = "v1"
        github_workspace = os.getenv("GITHUB_WORKSPACE", "")
        print("GITHUB_WORKSPACE:", github_workspace)

        api_dll_path = github_workspace+"/src/API/bin/Release/net6.0/API.dll"
        if not github_workspace:
            print("GITHUB_WORKSPACE environment variable is not set.")
            sys.exit(1)

        swagger_output_dir = Path(github_workspace) / "outputYAML" / env
        os.makedirs(swagger_output_dir, exist_ok=True)

        swagger_output_file = project_name+"-swag.yaml"
        complete_filePath = os.path.join(swagger_output_dir, swagger_output_file)
        print("swagger_output_file =", complete_filePath)

        prefix = os.getenv("PREFIX_URL", "")

        # Step 1: Generate swagger.yaml using dotnet CLI
        try:
            result = subprocess.run(["swagger", "tofile", "--output", complete_filePath, api_dll_path, api_version], check=True, capture_output=True, text=True)
            print("STDOUT:", result.stdout)
            print("STDERR:", result.stderr)
            print("Swagger YAML generated.")
        except subprocess.CalledProcessError as e:
            print("Command failed with return code:", e.returncode)
            print("Standard Output:\n", e.stdout)
            print("Standard Error:\n", e.stderr)
        except Exception as e:
            print("An unexpected error occurred:", str(e))

        with open(complete_filePath, "r") as f:
            openapi = yaml.safe_load(f)

        # Step 3: Group paths by common prefix
        grouped_paths = defaultdict(dict)
        if isinstance(openapi, dict) and "paths" in openapi:
            for path, path_data in openapi["paths"].items():
                if path.startswith("/api/"):
                    path_parts = path.split("/")
                    if len(path_parts) > 2:
                        base_name_part = path_parts[2].lower()
                        #clean_base_name = f"{base_name}"
                        clean_base_name = f"{prefix}-{base_name_part}" if prefix else base_name_part
                        trimmed_path = f"/api-{base_name_part}"
                        remaining_part = path[len(trimmed_path):]
                        new_path = f"/{clean_base_name}{remaining_part.split('/', 1)[1]}" if remaining_part else "/"
                        grouped_paths[clean_base_name][new_path] = path_data

        # Step 4: Split by path
        for clean_base_name, paths in grouped_paths.items():
            out_file = os.path.join(swagger_output_dir, f"{project_name}-api-{clean_base_name}.yaml")
            metadata = {
                "metadata": {
                    "name": f"oi-efr-npcentralus01-{project_name}-{clean_base_name}-{env}",
                    "namespace": namespace,
                },
                "kind": f"federated-azure-apim.api.{api_version}",
                "spec": {
                    "env": hcp_environment,
                    "apiName": f"{project_name}-{env}",
                    "upstreamUrlSuffix": f"{upstream_urlsuffixurl}/api/{clean_base_name}",
                    "openApiSpec": {
                        "servers": [{"url": f"{service_url}/api/{clean_base_name}"}],
                        "openapi": openapi.get("openapi", "3.0.0"),
                        "info": openapi.get("info", {}),
                        "components": openapi.get("components", {}),
                        "paths": paths,
                    },
                },
                "dataPlanes": [dataplane],
                "upstreamEnv": env,
                "catalogEnabled": True,
                "dataSensitivity": False,
                "subscriptionRequired": False,
            }
            print(f"SPLITTING PATHS INTO SEPARATE FILES IN '{swagger_output_dir}'...")
            with open(out_file, "w") as f:
                yaml.dump(metadata, f)

        # os.remove(swagger_output_file)

    - name: Find API .dll in src/api
      shell: bash
      run: ls -la ${{ github.workspace }}/outputYAML/${{ github.event.inputs.env_deploy }}/acctmgmtControllerdirYaml

    - name: Checking zip
      shell: bash
      run: |
        cd /outputYAML/${{ github.event.inputs.env_deploy }}/acctmgmtControllerdirYaml
        zip -r ${{ github.workspace }}/${{ inputs.project_name }}-api-worklisttoprocess_yaml-${{ inputs.artifactorytag }}.zip ./

    - name: Upload YAML to gitworkspace
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.hcpFile }}-${{ inputs.artifactorytag }}.zip
        path: ${{ github.workspace }}/${{ inputs.hcpFile }}-${{ inputs.artifactorytag }}.zip

    # - name: Debug split YAML files before cleanup
    #   shell: bash
